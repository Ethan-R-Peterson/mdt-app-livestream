<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MDT Livestream</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* simple, clean layout for the control bar */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
      justify-content: center;   /* center the whole row */
      padding: 6px 8px;
    }
    .controls label { white-space: nowrap; }
    .controls input[type="text"],
    .controls input[type="url"] {
      padding: 3px 6px;
      width: 320px;
      max-width: 42vw;
    }
    .controls button { padding: 3px 8px; }
  </style>
</head>
<body>
  <h1>MDT Livestream MVP</h1>

  <!-- Centered controls row -->
  <div class="controls">
    <label>Source:
      <select id="sourceSel">
        <option value="rgb_hls">RGB (HLS)</option>
        <option value="thermal_hls">Thermal (HLS)</option>
        <option value="thermal_mjpeg">Thermal (MJPEG)</option>
      </select>
    </label>

    <label>Stream URL:
      <input id="mediaUrl" type="url" placeholder="paste .m3u8 (HLS) or .mjpg (MJPEG)" autocomplete="off" />
    </label>
    <button id="playBtn">Play</button>
    <button id="stopBtn">Stop</button>

    <label>Telemetry WS:
      <input id="wsUrl" type="url" placeholder="ws://localhost:8765" autocomplete="off" />
    </label>
    <button id="wsBtn">Connect</button>
    <button id="wsDisconnectBtn">Disconnect</button>
    <button id="wsClearBtn">Clear</button>

    <label><input type="checkbox" id="hideTelemetry" /> Hide telemetry</label>
    <label><input type="checkbox" id="drawOverlay" checked /> Draw overlay</label>
  </div>

  <!-- Video (HLS/WebRTC later) + overlay -->
  <div id="video-wrap" style="position:relative; display:inline-block;">
    <video id="video" playsinline muted controls style="width: 800px; background:#000;"></video>
    <canvas id="overlay" width="800" height="450"
            style="position:absolute; left:0; top:0; pointer-events:none;"></canvas>
  </div>

  <!-- Thermal MJPEG fallback -->
  <div id="mjpeg-wrap" style="display:none;">
    <img id="mjpeg" alt="thermal stream" style="width:800px; background:#000;" />
  </div>

  <!-- Telemetry readout -->
  <pre id="telemetry" style="border:1px solid #ccc; padding:8px; width:800px; height:140px; overflow:auto; margin-top:8px;"></pre>

  <!-- Map mount point (Siddhant plugs in here later) -->
  <div id="map" style="width:800px;height:400px;margin-top:8px;border:1px dashed #aaa;display:flex;align-items:center;justify-content:center;">
    <span style="opacity:0.6;">Map placeholder — Siddhant mounts here</span>
  </div>

  <!-- Pin a specific HLS.js version for stability -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.15"></script>
  <script>
    // --- lightweight event bus so other modules (map) can subscribe to telemetry ---
    const Bus = {
      subs: {},
      on(evt, fn){ (this.subs[evt] ??= []).push(fn); },
      emit(evt, data){ (this.subs[evt]||[]).forEach(fn=>fn(data)); }
    };

    // Config (loaded from config.json if present). Keep EMPTY by default.
    const cfg = { sources:{}, telemetry_ws:"" };

    // OPTIONAL allowlist for stream URLs; set [] to allow any.
    const ALLOWLIST_HOSTS = ["localhost","127.0.0.1","10.0.0.3"];

    const els = {
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      overlayCtx: document.getElementById('overlay').getContext('2d'),
      telemetry: document.getElementById('telemetry'),
      srcSel: document.getElementById('sourceSel'),
      mediaUrl: document.getElementById('mediaUrl'),
      playBtn: document.getElementById('playBtn'),
      stopBtn: document.getElementById('stopBtn'),
      wsUrl: document.getElementById('wsUrl'),
      wsBtn: document.getElementById('wsBtn'),
      wsDisconnectBtn: document.getElementById('wsDisconnectBtn'),
      wsClearBtn: document.getElementById('wsClearBtn'),
      hideTelemetry: document.getElementById('hideTelemetry'),
      drawOverlayChk: document.getElementById('drawOverlay'),
      mjpegWrap: document.getElementById('mjpeg-wrap'),
      mjpeg: document.getElementById('mjpeg'),
      videoWrap: document.getElementById('video-wrap'),
    };

    let hls = null, ws = null;
    let drawOverlayEnabled = true;

    // --- helpers ---
    function isAllowedUrl(u){
      try{
        if(!u) return false;
        const url = new URL(u);
        return ALLOWLIST_HOSTS.length===0 || ALLOWLIST_HOSTS.includes(url.hostname);
      }catch{ return false; }
    }
    function log(text){
      els.telemetry.textContent += text + '\n';
      els.telemetry.scrollTop = els.telemetry.scrollHeight;
    }
    const fmt = x => (typeof x==='number' && x.toFixed) ? x.toFixed(2) : x;

    // --- config loader (never auto-play video / no auto-connect) ---
    async function loadConfig(){
      try{
        const r = await fetch('config.json', {cache:'no-store'});
        if(!r.ok) return;
        const j = await r.json();
        if (j && typeof j === 'object') {
          if (j.sources && typeof j.sources === 'object') cfg.sources = j.sources;
          if (j.telemetry_ws) els.wsUrl.value = j.telemetry_ws; // prefill only
        }
      }catch(e){
        console.warn('No config.json or invalid JSON; continuing with empty config.');
      }
    }

    // --- hard stop: destroys players, clears sources, resets canvas ---
    function stopPlayback(){
      try{ hls?.destroy(); }catch{}
      hls = null;
      try{
        els.video.pause();
        els.video.removeAttribute('src');
        els.video.load();
      }catch{}
      els.mjpeg.src = "";
      const ctx = els.overlayCtx, c = ctx.canvas;
      ctx.clearRect(0,0,c.width,c.height);
    }

    // --- HLS playback (manual only) ---
    function playHls(url){
      if (!isAllowedUrl(url)) return alert('Invalid or blocked URL (check allowlist or paste a valid .m3u8).');
      stopPlayback();
      els.mjpegWrap.style.display = 'none';
      els.videoWrap.style.display = 'inline-block';

      if (Hls.isSupported()){
        hls = new Hls({ liveSyncDurationCount: 2 });
        hls.loadSource(url);
        hls.attachMedia(els.video);
        hls.on(Hls.Events.MANIFEST_PARSED, () => els.video.play().catch(()=>{}));
      } else if (els.video.canPlayType('application/vnd.apple.mpegurl')) {
        els.video.src = url; // Safari native
        els.video.play().catch(()=>{});
      } else {
        alert('HLS not supported in this browser.');
      }
    }

    // --- MJPEG playback (manual only) ---
    function playMjpeg(url){
      if (!isAllowedUrl(url)) return alert('Invalid or blocked URL (check allowlist or paste a valid .mjpg).');
      stopPlayback();
      els.videoWrap.style.display = 'none';
      els.mjpegWrap.style.display = 'block';
      els.mjpeg.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
    }

    // --- overlay drawing from telemetry dets[] ---
    function drawOverlay(d){
      if (!drawOverlayEnabled) {
        const ctx0 = els.overlayCtx, c0 = ctx0.canvas;
        ctx0.clearRect(0,0,c0.width,c0.height);
        return;
      }
      const ctx = els.overlayCtx, c = ctx.canvas;
      ctx.clearRect(0,0,c.width,c.height);
      if (!Array.isArray(d?.dets)) return;
      ctx.lineWidth = 2;
      ctx.font = '14px monospace';
      d.dets.forEach(b=>{
        const x = Math.round((b.x||0)*c.width);
        const y = Math.round((b.y||0)*c.height);
        const w = Math.round((b.w||0)*c.width);
        const h = Math.round((b.h||0)*c.height);
        ctx.strokeRect(x,y,w,h);
        const label = `${b.label ?? 'obj'} ${Math.round((b.conf??0)*100)}%`;
        ctx.fillText(label, x+4, y+16);
      });
    }

    // --- telemetry websocket (manual connect / disconnect; no auto-connect/reconnect) ---
    function connectWs(url){
      if (!url) return alert('Enter WS URL (e.g., ws://localhost:8765)');
      try{ ws?.close(); }catch{}
      ws = new WebSocket(url);
      log(`WS connecting: ${url}`);
      ws.onopen  = ()=>{ log('WS connected'); };
      ws.onclose = ()=>{ log('WS closed'); };
      ws.onerror = ()=>{ log('WS error'); };
      ws.onmessage = (msg)=>{
        try{
          const d = JSON.parse(msg.data);
          Bus.emit('telemetry', d);   // map or other modules can listen
          log([
            `t=${d.time ?? ''}`,
            `lat=${d.lat ?? ''}, lon=${d.lon ?? ''}`,
            `alt=${fmt(d.alt)} m, gs=${fmt(d.gs)} m/s`,
            `batt=${d.batt ?? ''}%`,
            `yaw=${d.yaw ?? ''}°, pitch=${d.pitch ?? ''}°, roll=${d.roll ?? ''}`
          ].join(' | '));
          drawOverlay(d);
        }catch(e){
          log('Bad JSON: ' + msg.data);
        }
      };
    }

    function disconnectWs(){
      try { ws?.close(); } catch {}
      ws = null;
      log('WS disconnected (manual)');
    }

    // --- UI events ---
    document.addEventListener('DOMContentLoaded', async () => {
      await loadConfig(); // no auto actions

      // Source switch (no auto-play)
      els.srcSel.addEventListener('change', () => {
        const isMjpeg = els.srcSel.value.endsWith('mjpeg');
        els.videoWrap.style.display = isMjpeg ? 'none' : 'inline-block';
        els.mjpegWrap.style.display = isMjpeg ? 'block' : 'none';
        stopPlayback();
        const key = els.srcSel.value;
        const cfgUrl = (cfg.sources && cfg.sources[key]) || "";
        els.mediaUrl.value = cfgUrl || "";
      });

      els.playBtn.addEventListener('click', () => {
        const key = els.srcSel.value;
        const url = (els.mediaUrl.value || "").trim();
        if (!url) return alert('Paste a stream URL first.');
        if (key.endsWith('mjpeg')) playMjpeg(url);
        else playHls(url);
      });

      els.stopBtn.addEventListener('click', stopPlayback);

      els.wsBtn.addEventListener('click', () => {
        const url = (els.wsUrl.value || "").trim();
        connectWs(url);
      });

      els.wsDisconnectBtn.addEventListener('click', disconnectWs);

      els.wsClearBtn.addEventListener('click', () => {
        els.telemetry.textContent = '';
      });

      els.hideTelemetry.addEventListener('change', () => {
        els.telemetry.style.display = els.hideTelemetry.checked ? 'none' : 'block';
      });

      els.drawOverlayChk.addEventListener('change', () => {
        drawOverlayEnabled = els.drawOverlayChk.checked;
        if (!drawOverlayEnabled) {
          const ctx = els.overlayCtx, c = ctx.canvas;
          ctx.clearRect(0,0,c.width,c.height);
        }
      });

      // Initialize UI state
      els.srcSel.dispatchEvent(new Event('change'));

      // Example: map can subscribe to telemetry
      Bus.on('telemetry', (d) => {
        // map.updatePose?.(d.lat, d.lon, d.yaw);
      });
    });
  </script>
</body>
</html>
